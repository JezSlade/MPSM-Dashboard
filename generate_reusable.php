<?php
/**
 * generate_reusable.php
 * v1.0.2 [Compilation: aggregate @reusable components]
 *
 * Scans all PHP files under this directory (recursively),
 * finds every function or class preceded by an @reusable docblock,
 * then writes reusable_collection.php which:
 *  - lists each @reusable symbol in a file-level docblock
 *  - requires each source file so your debugger loads the real logic.
 */

declare(strict_types=1);

// --- CONFIG ---
$projectRoot = __DIR__;
$excludeDirs  = ['vendor', '.git'];
$outputFile   = $projectRoot . '/reusable_collection.php';

// --- COLLECT ---
$symbols = [];   // [ ['type'=>'function'|'class','name'=>FQCN], ... ]
$files   = [];

// Recursively iterate PHP files
$rii = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($projectRoot, FilesystemIterator::SKIP_DOTS)
);

foreach ($rii as $file) {
    if ($file->getExtension() !== 'php') {
        continue;
    }
    $path = $file->getPathname();
    if (basename($path) === basename(__FILE__) || $path === realpath($outputFile)) {
        continue;
    }
    foreach ($excludeDirs as $ex) {
        if (strpos($path, DIRECTORY_SEPARATOR . $ex . DIRECTORY_SEPARATOR) !== false) {
            continue 2;
        }
    }

    $code = file_get_contents($path);
    $tokens = token_get_all($code);

    $namespace   = '';
    $captureNext = null;
    $reusableDoc = false;

    foreach ($tokens as $tok) {
        if (is_array($tok)) {
            list($id, $text) = $tok;

            // Track namespace
            if ($id === T_NAMESPACE) {
                $namespace   = '';
                $captureNext = 'namespace';
                continue;
            }
            if ($captureNext === 'namespace' && ($id === T_STRING || $id === T_NS_SEPARATOR)) {
                $namespace .= $text;
                continue;
            }
            if ($captureNext === 'namespace' && $id !== T_WHITESPACE) {
                $captureNext = null;
            }

            // Detect @reusable in docblock
            if ($id === T_DOC_COMMENT && stripos($text, '@reusable') !== false) {
                $reusableDoc = true;
                continue;
            }

            // If flagged reusableDoc, capture class or function
            if ($reusableDoc && ($id === T_CLASS || $id === T_FUNCTION)) {
                $captureNext = $id === T_CLASS ? 'class' : 'function';
                $reusableDoc = false;
                continue;
            }

            // Capture the name token
            if ($captureNext && $id === T_STRING) {
                $name = $text;
                $fqdn = ($namespace !== '' ? '\\' . $namespace . '\\' : '\\') . $name;
                $symbols[] = [
                    'type' => $captureNext,
                    'name' => $fqdn,
                    'file' => $path
                ];
                $captureNext = null;
                // record file for require
                $files[$path] = true;
                continue;
            }
        }
    }
}

// --- GENERATE reusable_collection.php ---
$header = [
    '<?php',
    '/**',
    ' * reusable_collection.php',
    ' * Auto-generated by generate_reusable.php v1.0.2',
    ' *',
    ' * Components marked @reusable:',
];

foreach ($symbols as $sym) {
    $header[] = sprintf(
        ' * @reusable %s %s',
        $sym['type'],
        $sym['name']
    );
}

$header[] = ' */';
$header[] = '';

$content = implode("\n", $header);

// Add require_once lines
foreach (array_keys($files) as $filePath) {
    $rel = str_replace($projectRoot . DIRECTORY_SEPARATOR, '', $filePath);
    // normalize forward slashes
    $rel = str_replace('\\', '/', $rel);
    $content .= "require_once __DIR__ . '/{$rel}';\n";
}

// Write file
file_put_contents($outputFile, $content);

echo "✓ Generated {$outputFile} with " . count($symbols) . " reusable components.\n";
